/* ************************************************************************ */
/* 示例代码维护：沈阳航空航天工大学 计算机博弈研究组				    	*/
/* 己方棋子编码约定:														*/
/*	a司令,b军长,c师长,d旅长,e团长,f营长,g连长,h排长,i工兵,j地雷k炸弹,l军旗	*/
/* 对方方棋子编码约定:														*/
/*	A司令,B军长,C师长,D旅长,E团长,F营长,G连长,H排长,I工兵,J地雷K炸弹,L军旗	*/
/*	X未知对方棋子,0空棋位													*/
/* 最后更新：2012-03-31  meixian@hrbust.edu.cn								*/
/* 司令的走法 ，31步碰子尽量选择较小的棋子 （碰在己方棋盘上的子）	棋盘的评估
躲避敌方的31步	 第一种碰子失败，采取第二种方法，  特殊走法的生成（炸弹  工兵）
/* ************************************************************************ */
#include "Remakes.h"		//总备注
#include "HeaderFile.h"		//头文件
#include "ChessDefin.h"		//敌我棋子
#include "TheDaStr.h"		//涉及的数据结构
#include "BasicMove.h"		//基础行棋
#include "BoardPoints.h"	//棋盘分
#include "Madefin.h"		//宏定义
#include "Fresh.h"			//刷新棋盘
#include "Threat.h"			//各种威胁
#include "TraChess.h"		//各种刷新棋盘（存疑）
#include "DigLand.h"		//挖地雷
#include "Warn31.h"			//31步警告
#include "Spe1.h"			//特殊行棋1
#include "Spe2.h"			//特殊行棋2
#include "Spe3.h"			//特殊行棋3 
#include "Spe4.h"			//特殊行棋4
#include "Spe5.h"			//特殊行棋5
#include "Spe6.h"			//特殊行棋6
#include "Spe7.h"			//特殊行棋7
#include "Spe8.h"			//特殊行棋8
#include "Spe9.h"			//特殊行棋9
#include "BasisAss.h"		//基础评估函数
#include "DfsIn.h"			//DFS对应接口 
#include "RandIn.h"			//随机函数生成对应接口
#include "SysInf.h"			//系统对应的接口

int main()
{
	char cVer[200];			//协议版本
	int iFirst;				//先行权[0先行，1后行]																							//不知道iFirst、iTime、iStep有什么用？可能与平台有关系。
	int iTime;				//行棋时间限制(单位秒)[1000,3600]
	int iStep;				//进攻等待限制(单位步)[10,31]
	char cInMessage[200];   //输入通信内容
	char cOutMessage[200];  //输出通信内容
	char cIn1[200], cIn2[200];
	Map cMap[12][5];		//棋盘
	//  司令 ,军长 ,师长 ,旅长 ,团长 ,营长 ,连长 ,排长 ,工兵 ,地雷 ,炸弹 ,军旗     i,j,(该子所在位置)
	int Pro[25][14] = {
		100  ,100  ,250  ,500  ,500  ,700  ,2000 ,2100 ,400  ,3250 ,100  ,0    ,   0,0,//A0  10000
		0    ,0    ,0    ,0    ,0    ,0    ,0    ,3000 ,0    ,2000 ,0    ,5000 ,   0,1,//A1
		100  ,100  ,250  ,500  ,500  ,700  ,2000 ,2100 ,200  ,3250 ,100  ,0    ,   0,2,//A2
		0    ,0    ,0    ,0    ,0    ,0    ,0    ,3000 ,0    ,2000 ,0    ,5000 ,   0,3,//A3
		100  ,100  ,250  ,500  ,500  ,700  ,2000 ,2100 ,400  ,3250 ,100  ,0    ,   0,4,//A4

		500  ,500  ,850  ,700  ,600  ,500  ,600  ,500  ,1000 ,3250 ,1000 ,0    ,   1,0,//B0
		400  ,400  ,850  ,700  ,600  ,500  ,800  ,600  ,1000 ,3250 ,900  ,0    ,   1,1,//B1
		400  ,400  ,850  ,700  ,600  ,500  ,800  ,600  ,1000 ,3250 ,900  ,0    ,   1,2,//B2
		400  ,400  ,850  ,700  ,600  ,500  ,800  ,600  ,1000 ,3250 ,900  ,0    ,   1,3,//B3
		500  ,500  ,850  ,700  ,600  ,500  ,600  ,500  ,1000 ,3250 ,1000 ,0    ,   1,4,//B4

		500  ,500  ,1000 ,1000 ,1000 ,1500 ,500  ,500  ,2000 ,0    ,1500 ,0    ,   2,0,//C0
		500  ,500  ,1000 ,1000 ,1000 ,1500 ,500  ,500  ,2000 ,0    ,1500 ,0    ,   2,2,//C2
		500  ,500  ,1000 ,1000 ,1000 ,1500 ,500  ,500  ,2000 ,0    ,1500 ,0    ,   2,4,//C4

		500  ,500  ,1000 ,1000 ,1000 ,1500 ,500  ,500  ,2000 ,0    ,1500 ,0    ,   3,0,//D0
		500  ,500  ,1000 ,1000 ,1000 ,1500 ,500  ,500  ,2000 ,0    ,1500 ,0    ,   3,1,//D1
		500  ,500  ,1000 ,1000 ,1000 ,1500 ,500  ,500  ,2000 ,0    ,1500 ,0    ,   3,3,//D3
		500  ,500  ,1000 ,1000 ,1000 ,1500 ,500  ,500  ,2000 ,0    ,1500 ,0    ,   3,4,//D4

		500  ,500  ,1000 ,1000 ,1000 ,1500 ,500  ,500  ,2000 ,0    ,1500 ,0    ,   4,0,//E0
		500  ,500  ,1000 ,1000 ,1000 ,1500 ,500  ,500  ,2000 ,0    ,1500 ,0    ,   4,2,//E2
		500  ,500  ,1000 ,1000 ,1000 ,1500 ,500  ,500  ,2000 ,0    ,1500 ,0    ,   4,4,//E4

		500  ,500  ,1000 ,1000 ,1200 ,2800 ,1500 ,1500 ,0    ,0    ,0    ,0    ,   5,0,//F0
		500  ,500  ,1000 ,1000 ,1000 ,1000 ,1500 ,1500 ,2000 ,0    ,0    ,0    ,   5,1,//F1
		500  ,500  ,1000 ,1000 ,1100 ,2800 ,1600 ,1500 ,0    ,0    ,0    ,0    ,   5,2,//F2
		500  ,500  ,1000 ,1000 ,1000 ,1000 ,1500 ,1500 ,2000 ,0    ,0    ,0    ,   5,3,//F3
		500  ,500  ,1000 ,1000 ,1200 ,2800 ,1500 ,1500 ,0    ,0    ,0    ,0    ,   5,4,//F4
	};
	cin.getline(cInMessage, 200);		//获取来自裁判系统的指令 "GO 0000 0 00"8
	while (cInMessage[0] >= 'A')
	{
		switch (cInMessage[0])
		{

		case 'I':								//INFO指令
			CulInfo(cInMessage, cVer, cOutMessage);
			cout << cOutMessage << endl;			//将"NAME "指令传递给裁判系统
			break;
		case 'S':								//START 指令
			CulArray(cInMessage, &iFirst, &iTime, &iStep, cOutMessage);
			InitMap(cMap, cOutMessage);
			cout << cOutMessage << endl;
			break;
		case 'G':								//GO 指令
			FreshMap(cMap, cInMessage, cOutMessage, Pro);
			CulBestmove(cMap, cInMessage, cOutMessage, Pro);
			cout << cOutMessage << endl;
			break;
		case 'R':								//RESULT 指令
			FreshMap(cMap, cInMessage, cOutMessage, Pro);
			//	cout<<cOutMessage<<endl;
			break;
		case 'E':								//END 指令
			return 0;
		default:
			return 1;
		}
		strcpy(cIn1, cInMessage);
		while (1) {
			gets(cInMessage);
			if (cInMessage[0] >= 'A') {
				break;
			}
		}
		strcpy(cIn2, cInMessage);
	}
	return 0;
}

