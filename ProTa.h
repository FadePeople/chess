#pragma once				//上个头文件只编译一次


/* ************************************************************************ */
/* 函数功能：判断是某个棋子的概率                                      		*/
/* 接口参数：																*/
/*     int i													            */
/*     int j		  所要判断棋子的位置								    */
/*     int k		  棋子编号  											*/
/*     int Pro[25][14] 敌方棋子概率							                */
/* ************************************************************************ */
int Judge(int i, int j, int k, int Pro[25][14])
{
	for (int n = 0; n < 25; n++)
	{
		if (Pro[n][12] == i && Pro[n][13] == j)
			return Pro[n][k];
	}
	return 0;
}


int qipanfen[12][5] = {     //初始棋盘分
	500 ,1000,600 ,1000,800,  
	200 ,600 ,500 ,600 ,200,
	250 ,800 ,20  ,800 ,250,
	140 ,20  ,700 ,20  ,140,
	130 ,400 ,20  ,400 ,130,
	120 ,80  ,150 ,80  ,120,
	110 ,100 ,50 ,100 ,110,
	100 ,500 ,150  ,500 ,100,
	100 ,20  ,400 ,20  ,100,
	100 ,600 ,20  ,600 ,100,
	500 ,100 ,100 ,100 ,500,
	200 ,-1000 ,200 ,-1000 ,200 };


/* ************************************************************************ */
/* 函数功能：根据敌我军旗位置设定的分数                                     */
/* 接口参数：																*/
/*     Map cMap       目前的棋盘								            */
/*     int Pro		  概率表											    */
/* ************************************************************************ */
void jushipg(Map cMap[12][5], int Pro[25][14])
{
	if (cMap[11][1].chess == 'l')//己方军旗的位置在左
	{
		qipanfen[6][0] = 130;
		qipanfen[7][0] = 120;
		qipanfen[7][1] = 600;
		qipanfen[8][0] = 120;
		qipanfen[8][1] = 80;
		qipanfen[9][0] = 120;
		qipanfen[9][1] = 700;
		qipanfen[10][0] = 600;
		qipanfen[10][1] = 200;
	}
	if (cMap[11][3].chess == 'l')//己方军旗的位置在右
	{
		qipanfen[6][4] = 130;
		qipanfen[7][4] = 120;
		qipanfen[7][3] = 600;
		qipanfen[8][4] = 120;
		qipanfen[8][3] = 80;
		qipanfen[9][4] = 120;
		qipanfen[9][3] = 700;
		qipanfen[10][4] = 600;
		qipanfen[10][3] = 200;
	}
	if (Pro[1][11] >= 10000)//如果对面左面大本营的军旗分达到10000分，其他部分进行修改
	{
		qipanfen[0][3] = -10000;
		qipanfen[0][4] = -10000;
		qipanfen[0][1] = 10000;
		qipanfen[0][0] = 600;
		qipanfen[1][0] = 400;
		qipanfen[1][1] = 700;
		qipanfen[2][0] = 300;
		qipanfen[2][1] = 900;
		qipanfen[3][0] = 240;
		qipanfen[3][1] = 100;
		qipanfen[4][0] = 230;
		qipanfen[4][1] = 500;
		qipanfen[5][0] = 220;
	}
	if (Pro[3][11] >= 10000)//如果对面右面大本营的军旗分达到10000分，其他部分进行修改
	{
		qipanfen[0][1] = -10000;
		qipanfen[0][0] = -10000;
		qipanfen[0][3] = 10000;
		qipanfen[0][4] = 600;
		qipanfen[1][4] = 400;
		qipanfen[1][3] = 700;
		qipanfen[2][4] = 300;
		qipanfen[2][3] = 900;
		qipanfen[3][4] = 240;
		qipanfen[3][3] = 100;
		qipanfen[4][4] = 230;
		qipanfen[4][3] = 500;
		qipanfen[5][4] = 220;
	}
}


/* ************************************************************************ */
/* 函数功能：         回收分数                             		            */
/* 接口参数：																*/
/*     int n		  要回收的棋子，（概率表的某一列）						*/
/*     int i		  棋子序号											    */
/*     int sfen		  棋子编号  											*/
/*     int Pro[25][14] 敌方棋子概率							                */
/* ************************************************************************ */
void souhui(int n, int i, int sfen, int Pro[25][14])         //sfen 回收的分数   n为旗子位置   i为旗子大小
{
	int zong = 0;
	int n1;
	if (sfen == 0)
		return;
	if (i == 0 || i == 1 || i == 11)//因为司令，军长，军旗只有一个，分配总分为10000
		zong = 10000;
	else if (i > 5 && i < 10)//这中间的棋子个数为3，总分为30000
		zong = 30000;
	else//剩下的为20000
		zong = 20000;
	for (n1 = 0; n1 < 25; n1++)
	{
		if (n1 != n && (zong - Pro[n][i]) != 0 && Pro[n1][i] < 9500)
			Pro[n1][i] = (int)(1.0*Pro[n1][i] * (1 - 1.0*sfen / (zong - Pro[n][i])));
	}
}



/* ************************************************************************ */
/* 函数功能：刷新工兵的概率 							    				*/
/* 接口参数：																*/
/*     char cMap 棋盘 											            */
/*     int i1,ji  起点坐标（敌方棋子初始坐标）           				    */
/*     int i2,j2  落点坐标	                 					            */
/*     int Pro[25][14]  概率表                                              */
/* ************************************************************************ */
int RefreshSapper(Map cMap[12][5], int Pro[25][14], int i1, int j1, int i2, int j2)
{
	int n, n1;
	int i, j;
	int zong = 0;
	if ((i1 != i2) && (j1 != j2))//起点终点不在一条线上
	{
		for (n = 0; n < 25; n++)
		{
			if (Pro[n][12] == i1 && Pro[n][13] == j1)
			{
				//Pro[n][12] = 14;00
				for (i = 0; i < 12; i++)
				{
					if (Pro[n][i] != 0 && i != 8 && Pro[n][i] != 10000)//把不是工兵的其他列重新按权分配好，10000和0不分因为是已经确定的了
					{
						if (i == 0 || i == 1 || i == 11)//司令，军长，军旗只有一个
							zong = 10000;
						else if (i > 5 && i < 10)//这之内的子有三个
							zong = 30000;
						else//这中间的子有两个
							zong = 20000;
						for (n1 = 0; n1 < 25; n1++)//按列重新按权分配概率表
							if (n1 != n && Pro[n1][i] < 9000)
								Pro[n1][i] = (int)(1.0*Pro[n1][i] * (1 + 1.0*Pro[n][i] / (zong - Pro[n][i])));
						Pro[n][i] = 0;
					}
				}
				souhui(n, 8, 10000 - Pro[n][8], Pro);
				Pro[n][8] = 10000;		//工兵分值变10000
			}
		}
		return 1;
	}
	else if ((i1 == i2) && (j1 != j2))//在一条横线上
	{
		if ((i1 != 1) && (i1 != 5) && (i1 != 6) && (i1 != 10))//不在2，6，7，11行铁轨上
		{
			for (n = 0; n < 25; n++)
			{
				if (Pro[n][12] == i1 && Pro[n][13] == j1)
				{
					//Pro[n][12] = 14;
					for (i = 0; i < 12; i++)
					{
						if (Pro[n][i] != 0 && i != 8 && Pro[n][i] != 10000)
						{
							if (i == 0 || i == 1 || i == 11)
								zong = 10000;
							else if (i > 5 && i < 10)
								zong = 30000;
							else
								zong = 20000;
							for (n1 = 0; n1 < 25; n1++)
								if (n1 != n && Pro[n1][i] < 9000)
									Pro[n1][i] = (int)(1.0*Pro[n1][i] * (1 + 1.0*Pro[n][i] / (zong - Pro[n][i])));
							Pro[n][i] = 0;
						}
					}
					souhui(n, 8, 10000 - Pro[n][8], Pro);
					Pro[n][8] = 10000;		//工兵分值变10000
				}
			}
			return 1;
		}
		else//在2，6，7，11行铁轨上
		{
			for (j = min(j1, j2) + 1; j < max(j1, j2); j++)
			{
				if (cMap[i1][j].chess != '0')
				{
					for (n = 0; n < 25; n++)
					{
						if (Pro[n][12] == i1 && Pro[n][13] == j1)
						{
							//Pro[n][12] = 14;
							for (i = 0; i < 12; i++)
							{
								if (Pro[n][i] != 0 && i != 8 && Pro[n][i] != 10000)
								{
									if (i == 0 || i == 1 || i == 11)
										zong = 10000;
									else if (i > 5 && i < 10)
										zong = 30000;
									else
										zong = 20000;
									for (n1 = 0; n1 < 25; n1++)
										if (n1 != n && Pro[n1][i] < 9000)
											Pro[n1][i] = (int)(1.0*Pro[n1][i] * (1 + 1.0*Pro[n][i] / (zong - Pro[n][i])));
									Pro[n][i] = 0;
								}
							}
							souhui(n, 8, 10000 - Pro[n][8], Pro);
							Pro[n][8] = 10000;		//工兵分值变10000
							return 1;
						}
					}
				}
			}
			return 0;
		}
	}
	else if ((i1 != i2) && (j1 == j2))//在一列上
	{
		if ((j1 != 0) && (j1 != 4))//不在1，4列上
		{
			if ((j1 == 2) && (i1 + i2 == 11))
			{
				return 0;
			}
			else
			{
				for (n = 0; n < 25; n++)
				{
					if (Pro[n][12] == i1 && Pro[n][13] == j1)
					{
						Pro[n][12] = 14;
						for (i = 0; i < 12; i++)
						{
							if (Pro[n][i] != 0 && i != 8 && Pro[n][i] != 10000)
							{
								if (i == 0 || i == 1 || i == 11)
									zong = 10000;
								else if (i > 5 && i < 10)
									zong = 30000;
								else
									zong = 20000;
								for (n1 = 0; n1 < 25; n1++)
									if (n1 != n && Pro[n1][i] < 9000)
										Pro[n1][i] = (int)(1.0*Pro[n1][i] * (1 + 1.0*Pro[n][i] / (zong - Pro[n][i])));
								Pro[n][i] = 0;
							}
						}
						souhui(n, 8, 10000 - Pro[n][8], Pro);
						Pro[n][8] = 10000;		//工兵分值变10000
						return 1;
					}
				}
			}
			return 0;
		}
		else//在1，4列上
		{
			for (i = min(i1, i2) + 1; i < max(i1, i2); i++)
			{
				if (cMap[i][j1].chess != '0')
				{
					for (n = 0; n < 25; n++)
					{
						if (Pro[n][12] == i1 && Pro[n][13] == j1)
						{
							//Pro[n][12] = 14;
							for (i = 0; i < 12; i++)
							{
								if (Pro[n][i] != 0 && i != 8 && Pro[n][i] != 10000)
								{
									if (i == 0 || i == 1 || i == 11)
										zong = 10000;
									else if (i > 5 && i < 10)
										zong = 30000;
									else
										zong = 20000;
									for (n1 = 0; n1 < 25; n1++)
										if (n1 != n && Pro[n1][i] < 9000)
											Pro[n1][i] = (int)(1.0*Pro[n1][i] * (1 + 1.0*Pro[n][i] / (zong - Pro[n][i])));
									Pro[n][i] = 0;
								}
							}
							souhui(n, 8, 10000 - Pro[n][8], Pro);
							Pro[n][8] = 10000;		//工兵分值变10000
							return 1;
						}
					}
				}
			}
		}
		return 0;
	}
	else
	{
		return 0;
	}
	return 0;
}
