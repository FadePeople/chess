#pragma once				//上个头文件只编译一次
/* ************************************************************************ */
/* 函数功能：i,j位置是否本方棋子											*/
/* 接口参数：																*/
/*     char cMap[12][5] 棋盘局面											*/
/*     int i,j 棋盘位置行列号												*/
/* 返回值：																	*/
/*     1己方棋子，0空棋位或对方棋子											*/
/* ************************************************************************ */
int IsMyChess(Map cMap[12][5], int i, int j)
{
	if (cMap[i][j].chess >= 'a'&& cMap[i][j].chess <= 'l')
		return 1;
	else
		return 0;
}

/* ************************************************************************ */
/* 函数功能：i,j位置是否本方可移动的棋子									*/
/* 接口参数：																*/
/*     char cMap[12][5] 棋盘局面											*/
/*     int i,j 棋盘位置行列号												*/
/* 返回值：																	*/
/*     1己方可移动棋子(司令,军长,...,工兵,炸弹)，0军旗,地雷,对方棋子或空棋位*/
/* ************************************************************************ */
int IsMyMovingChess(Map cMap[12][5], int i, int j)
{
	if (cMap[i][j].chess >= 'a' && cMap[i][j].chess <= 'i' || cMap[i][j].chess == 'k')
		return 1;
	else
		return 0;
}

/* ************************************************************************ */
/* 函数功能：i,j位置是否山界后的兵站										*/
/* 接口参数：																*/
/*     int i,j 棋盘位置行列号												*/
/* 返回值：																	*/
/*     1处于山界后，0不处于山界后											*/
/* ************************************************************************ */
int IsAfterHill(int i, int j)
{
	if (i * 5 + j == 31 || i * 5 + j == 33)
		return 1;
	else
		return 0;
}

/* ************************************************************************ */
/* 函数功能：i,j位置是否行营												*/
/* 接口参数：																*/
/*     int i,j 棋盘位置行列号												*/
/* 返回值：																	*/
/*     1是行营，0不是行营													*/
/* ************************************************************************ */
int IsMoveCamp(int i, int j)
{
	if (i * 5 + j == 11 || i * 5 + j == 13 || i * 5 + j == 17 || i * 5 + j == 21 || i * 5 + j == 23 || i * 5 + j == 36 || i * 5 + j == 38 || i * 5 + j == 42 || i * 5 + j == 46 || i * 5 + j == 48)
		return 1;
	else
		return 0;
}

//函数功能：判断旗子是否在铁轨上
//int int （i，j）为棋盘位置行列号
int IsRailway(int i, int j)
{
	if (i == 1 || i == 5 || i == 6 || i == 10 || ((j == 0 || j == 4) && i > 0 && i < 11))
		return 1;
	else
		return 0;
}
/* ************************************************************************ */
/* 函数功能：i,j位置是否是对手棋子											*/
/* 接口参数：																*/
/*     char cMap[12][5]	棋盘局面											*/
/*     int i, j	棋盘位置行列号												*/
/* 返回值：																	*/
/*     1对手棋子，0空棋位或己方棋子											*/
/* ************************************************************************ */
int IsOppChess(Map cMap[12][5], int i, int j)
{
	if (cMap[i][j].chess >= 'A' && cMap[i][j].chess <= 'X')
		return 1;
	else
		return 0;
}

//函数功能：i,j位置是否山界前的兵站
int IsBehindHill(int i, int j)
{
	if (i * 5 + j == 26 || i * 5 + j == 28)
		return 1;
	else
		return 0;
}

/* ************************************************************************ */
/* 函数功能：工兵拐弯的搜索                                          		*/
/* 接口参数：																*/
/*     char cTryMap	尝试棋盘局面											*/
/*     int x	横坐标														*/
/*     int y	纵坐标														*/
/*     int iSaMove	记录工兵的铁路线走法									*/
/*     int iNum	已存走法数量												*/
/* 返回值：	初始: iNum=0															*/
/* ************************************************************************ */
int SapperRail(int iSaMove[40][2], Map cTryMap[12][5], int x, int y, int iNum)
{
	int i, t;
	//可以前移:不在第一行,不在山界后,前方是空,落在铁道线上
	if (x > 0 && !IsAfterHill(x, y) && (cTryMap[x - 1][y].chess == '0' || IsOppChess(cTryMap, x - 1, y)) && IsRailway(x - 1, y))
	{
		t = 0;
		for (i = 0; i <= iNum; i++)
		{
			if ((x - 1) == iSaMove[i][0] && y == iSaMove[i][1])//查出重复走法，跳出循环
				t = 1;
		}

		if (t == 0)
		{
			iNum++;
			iSaMove[iNum][0] = x - 1;
			iSaMove[iNum][1] = y;
			if (cTryMap[x - 1][y].chess == '0')
			{
				cTryMap[x][y].chess = '0';
				cTryMap[x - 1][y].chess = 'i';
				iNum = SapperRail(iSaMove, cTryMap, x - 1, y, iNum);
				cTryMap[x][y].chess = 'i';
				cTryMap[x - 1][y].chess = '0';
			}
		}
	}

	//可以左移:不在最左列,左侧是空,落在铁道线上
	if (y > 0 && (cTryMap[x][y - 1].chess == '0' || IsOppChess(cTryMap, x, y - 1)) && IsRailway(x, y - 1))
	{
		t = 0;
		for (i = 0; i <= iNum; i++)
		{
			if (x == iSaMove[i][0] && (y - 1) == iSaMove[i][1])
				t = 1;
		}

		if (t == 0)
		{
			iNum++;
			iSaMove[iNum][0] = x;
			iSaMove[iNum][1] = y - 1;
			if (cTryMap[x][y - 1].chess == '0')
			{
				cTryMap[x][y].chess = '0';
				cTryMap[x][y - 1].chess = 'i';
				iNum = SapperRail(iSaMove, cTryMap, x, y - 1, iNum);
				cTryMap[x][y].chess = 'i';
				cTryMap[x][y - 1].chess = '0';
			}
		}
	}

	//可以右移://不在最右列,右侧不是己方棋子,落在铁道线上
	if (y < 4 && (cTryMap[x][y + 1].chess == '0' || IsOppChess(cTryMap, x, y + 1)) && IsRailway(x, y + 1))
	{
		t = 0;
		for (i = 0; i <= iNum; i++)
		{
			if (x == iSaMove[i][0] && (y + 1) == iSaMove[i][1])
				t = 1;
		}

		if (t == 0)
		{
			iNum++;
			iSaMove[iNum][0] = x;
			iSaMove[iNum][1] = y + 1;
			if (cTryMap[x][y + 1].chess == '0')
			{
				cTryMap[x][y].chess = '0';
				cTryMap[x][y + 1].chess = 'i';
				iNum = SapperRail(iSaMove, cTryMap, x, y + 1, iNum);
				cTryMap[x][y].chess = 'i';
				cTryMap[x][y + 1].chess = '0';
			}
		}
	}

	//可以后移:不在最后一行,不在山界前,后方不是己方棋子,落在铁道线上
	if (x < 11 && !IsBehindHill(x, y) && (cTryMap[x + 1][y].chess == '0' || IsOppChess(cTryMap, x + 1, y)) && IsRailway(x + 1, y))
	{
		t = 0;
		for (i = 0; i <= iNum; i++)
		{
			if ((x + 1) == iSaMove[i][0] && y == iSaMove[i][1])
				t = 1;
		}

		if (t == 0)
		{
			iNum++;
			iSaMove[iNum][0] = (x + 1);
			iSaMove[iNum][1] = y;
			if (cTryMap[x + 1][y].chess == '0')
			{
				cTryMap[x][y].chess = '0';
				cTryMap[x + 1][y].chess = 'i';
				iNum = SapperRail(iSaMove, cTryMap, x + 1, y, iNum);
				cTryMap[x][y].chess = 'i';
				cTryMap[x + 1][y].chess = '0';
			}
		}
	}

	return iNum;
}
//用于计算我方可移动棋子总数
//返回值 棋子个数
int MyMovingChess(Map cMap[12][5])
{
	int i, j;
	int n = 0;
	int N = 0;
	for (i = 0; i < 12; i++)
		for (j = 0; j < 5; j++)
			if (cMap[i][j].chess >= 'a'&&cMap[i][j].chess <= 'i' || cMap[i][j].chess == 'k')
			{
				if (i == 11 && j == 1)
					;
				else if (i == 11 && j == 3)
					;
				else if (i == 0 && j == 1)
					;
				else if (i == 0 && j == 3)
					;
				else
					n++;
			}
	return n;
}
/* ************************************************************************ */
/* 函数功能：i,j位置是否大本营											*/
/* 接口参数：																*/
/*     int i,j 棋盘位置行列号												*/
/* 返回值：																	*/
/*     1是大本营，0不是大本营												*/
/* ************************************************************************ */
int IsBaseCamp(int i, int j)
{
	if (i * 5 + j == 1 || i * 5 + j == 3 || i * 5 + j == 56 || i * 5 + j == 58)
		return 1;
	else
		return 0;
}

/* ************************************************************************ */
/* 函数功能：i,j位置是否有棋子占位的行营									*/
/* 接口参数：																*/
/*     char cMap[12][5] 棋盘局面											*/
/*     int i,j 棋盘位置行列号												*/
/* 返回值：																	*/
/*     1有棋子占位的行营,0不是行营或是空行营								*/
/* ************************************************************************ */
int IsFilledCamp(Map cMap[12][5], int i, int j)
{
	if (IsMoveCamp(i, j) && cMap[i][j].chess != '0')
		return 1;
	else
		return 0;
}

//行营划分
/*
a b
 c
d e
1 2
 3
4 5
*/
/* ************************************************************************ */
/* 函数功能：i,j位置为不在行营且可以向左前方移动的旗子						*/
/* 接口参数：																*/
/*     int i,j 棋盘位置行列号												*/
/* 返回值：																	*/
/*     1是特殊点0不是														*/
/* ************************************************************************ */
int Iszuoqian(int i, int j)
{
	if (i * 5 + j == 19 || i * 5 + j == 29 || i * 5 + j == 27 || i * 5 + j == 44 || i * 5 + j == 52 || i * 5 + j == 54)
		//3 4				5 4					5 2				8 4					10 2				10 4
		return 1;
	else
		return 0;
}

/* ************************************************************************ */
/* 函数功能：i,j位置为不在行营且可以向右前方移动的旗子						*/
/* 接口参数：																*/
/*     int i,j 棋盘位置行列号												*/
/* 返回值：																	*/
/*     1是特殊点0不是														*/
/* ************************************************************************ */
int Isyouqian(int i, int j)
{
	if (i * 5 + j == 15 || i * 5 + j == 25 || i * 5 + j == 27 || i * 5 + j == 40 || i * 5 + j == 50 || i * 5 + j == 52)
		//
		return 1;
	else
		return 0;
}

/* ************************************************************************ */
/* 函数功能：i,j位置为不在行营且可以向左后方移动的旗子						*/
/* 接口参数：																*/
/*     int i,j 棋盘位置行列号												*/
/* 返回值：																	*/
/*     1是特殊点0不是														*/
/* ************************************************************************ */
int Iszuohou(int i, int j)
{
	if (i * 5 + j == 7 || i * 5 + j == 9 || i * 5 + j == 19 || i * 5 + j == 32 || i * 5 + j == 34 || i * 5 + j == 44)
		return 1;
	else
		return 0;
}

/* ************************************************************************ */
/* 函数功能：i,j位置为不在行营且可以向右后方移动的旗子						*/
/* 接口参数：																*/
/*     int i,j 棋盘位置行列号												*/
/* 返回值：																	*/
/*     1是特殊点0不是														*/
/* ************************************************************************ */
int Isyouhou(int i, int j)
{
	if (i * 5 + j == 5 || i * 5 + j == 7 || i * 5 + j == 15 || i * 5 + j == 30 || i * 5 + j == 32 || i * 5 + j == 40)
		return 1;
	else
		return 0;
}

/* ************************************************************************ */
/* 函数功能：计算我方棋子还剩多少个											*/
/* 接口参数：																*/
/*     cMap 当前地图														*/
/* 返回值：																	*/
/*     我方剩余棋子															*/
/* ************************************************************************ */
int NumChess(Map cMap[12][5])
{
	int n = 0; //我方棋子数
	int i, j;

	for (i = 0; i < 12; i++)
		for (j = 0; j < 5; j++)
			if (cMap[i][j].chess >= 'a'&&cMap[i][j].chess <= 'l')
				n++;
	return n;
}

/* ************************************************************************ */
/* 函数功能：计算敌方棋子还剩多少个											*/
/* 接口参数：																*/
/*     cMap 当前地图														*/
/* 返回值：																	*/
/*     敌方剩余棋子															*/
/* ************************************************************************ */
int NumOppChess(Map cMap[12][5])
{
	int n = 0; //我敌棋子数
	int i, j;

	for (i = 0; i < 12; i++)
		for (j = 0; j < 5; j++)
			if (cMap[i][j].chess >= 'A'&&cMap[i][j].chess <= 'X')
				n++;
	return n;
}

/* ************************************************************************ */
/* 函数功能：将我方棋子按照棋力的大小排序									*/
/* 接口参数：																*/
/*     cMap 当前地图	mc排好顺序的数组									*/
/* 返回值：																	*/
/*     空，直接传进数组															*/
/* ************************************************************************ */
void mychessdx(Map cMap[12][5], char mc[25])   //将我方棋子按照棋力的大小排序
{												//找到我方棋子除了司令最大的两个
	int i = 0, l;
	for (int i2 = 0; i2 < 12; i2++)  // 找己方炸弹的数目
	{
		for (int j2 = 0; j2 < 5; j2++)
			if (cMap[i2][j2].chess >= 'a' && cMap[i2][j2].chess <= 'l')
			{
				mc[i] = cMap[i2][j2].chess;
				i++;
				l = i;
			}
	}
	for (i = 0; i < l; i++)
	{
		for (int j = 0; j + i < l - 1; j++)
		{
			if (mc[j] > mc[j + 1])
			{
				char flag = mc[j];
				mc[j] = mc[j + 1];
				mc[j + 1] = flag;
			}
		}
	}
}

/* ************************************************************************ */
/* 函数功能：判断是某个棋子的概率                                      		*/
/* 接口参数：																*/
/*     int i													            */
/*     int j		  所要判断棋子的位置								    */
/*     int k		  棋子编号  											*/
/*     int Pro[25][14] 敌方棋子概率							                */
/* ************************************************************************ */
int Judge(int i, int j, int k, int Pro[25][14])
{
	for (int n = 0; n < 25; n++)
	{
		if (Pro[n][12] == i && Pro[n][13] == j)
			return Pro[n][k];
	}
	return 0;
}